<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird Pro</title>
    <style>
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh;
            background: #4ec0ca; font-family: 'Arial Rounded MT Bold', Arial, sans-serif; touch-action: manipulation; overflow: hidden; }
        #game-container { position: relative; width: 800px; height: 1000px; max-width: 95%; max-height: 95vh; }
        #game-canvas { width: 100%; height: 100%; }
        #score-display { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: white;
            font-size: 60px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 2; }
        #game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9);
            padding: 30px; border-radius: 20px; color: white; text-align: center; display: none; z-index: 3;
            box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        #start-screen { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; z-index: 2; color: white; }
        button { background: #f1c40f; border: none; padding: 15px 30px; border-radius: 10px; color: black;
            font-weight: bold; cursor: pointer; margin: 10px; font-size: 20px; transition: transform 0.1s; }
        button:active { transform: scale(0.95); }
        #countdown { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); 
            font-size: 100px; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); display: none; }
        #pause-menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            display: none; text-align: center; z-index: 4; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="start-screen">
            <h1>Flappy Bird Pro</h1>
            <button onclick="startGame()">Start Game</button>
        </div>
        <div id="score-display">0</div>
        <div id="countdown">3</div>
        <div id="pause-menu">
            <button onclick="resumeGame()">Resume</button>
            <button onclick="restartGame()">Restart</button>
        </div>
        <canvas id="game-canvas"></canvas>
        <div id="game-over">
            <h2>Game Over!</h2>
            <p>Score: <span id="final-score">0</span></p>
            <p>Best: <span id="best-score">0</span></p>
            <button onclick="startGame()">Play Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const gameOverScreen = document.getElementById('game-over');
        const finalScore = document.getElementById('final-score');
        const bestScoreElement = document.getElementById('best-score');
        const pauseMenu = document.getElementById('pause-menu');
        const countdownElement = document.getElementById('countdown');

        // Game assets
        const images = { bird: new Image(), pipeTop: new Image(), pipeBottom: new Image(), background: new Image() };
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Game state
        let gameState = { 
            bird: { 
                x: 200, 
                y: 400, 
                velocity: 0, 
                gravity: 0.5, 
                jump: -12,
                size: 90,
                rotation: 0 
            },
            pipes: [], 
            score: 0, 
            bestScore: localStorage.getItem('bestScore') || 0, 
            isPlaying: false, 
            isPaused: false, 
            lastPipeSpawn: 0, 
            pipeWidth: 200,
            gameSpeed: 2.6,
            particles: [], 
            birdCanFall: false
        };

        // Sound functions
        function playFlap() {
            const oscillator = audioContext.createOscillator(), gainNode = audioContext.createGain();
            oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime); oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination); oscillator.start(); oscillator.stop(audioContext.currentTime + 0.1);
        }

        function playPoint() {
            const oscillator = audioContext.createOscillator(), gainNode = audioContext.createGain();
            oscillator.type = 'square'; oscillator.frequency.setValueAtTime(1500, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime); oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination); oscillator.start(); oscillator.stop(audioContext.currentTime + 0.1);
        }

        function playHit() {
            const oscillator = audioContext.createOscillator(), gainNode = audioContext.createGain();
            oscillator.type = 'square'; oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime); oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination); oscillator.start(); oscillator.stop(audioContext.currentTime + 0.6);
        }

        // Load images
        images.bird.src = 'https://iili.io/3uPmhZJ.md.png';
        images.pipeTop.src = 'https://iili.io/3u4luRI.md.png';
        images.pipeBottom.src = 'https://iili.io/3u4luRI.md.png';
        images.background.src = 'https://iili.io/3u4j6yG.md.png';

        // Pipe generator
        class Pipe {
            static lastUpperLonger = false;

            constructor() {
                this.x = canvas.width;
                const minGap = 200;
                const maxGap = 300;
                this.pipeGap = minGap + Math.random() * (maxGap - minGap);
                const minPipeHeight = 50;
                const maxPipeHeight = canvas.height - this.pipeGap - minPipeHeight;
                
                Pipe.lastUpperLonger = !Pipe.lastUpperLonger;
                
                if(Pipe.lastUpperLonger) {
                    this.topHeight = minPipeHeight + Math.random() * (maxPipeHeight - minPipeHeight);
                    this.bottomY = this.topHeight + this.pipeGap;
                } else {
                    this.bottomY = canvas.height - minPipeHeight - Math.random() * (maxPipeHeight - minPipeHeight);
                    this.topHeight = this.bottomY - this.pipeGap;
                }
                this.scored = false;
            }
            update() { this.x -= gameState.gameSpeed; }
            draw() {
                ctx.drawImage(images.pipeTop, this.x, 0, gameState.pipeWidth, this.topHeight);
                ctx.drawImage(images.pipeBottom, this.x, this.bottomY, gameState.pipeWidth, canvas.height - this.bottomY);
            }
        }

        // Resize canvas
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            gameState.bird.y = canvas.height / 2;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Bird class
        class Bird {
            update() {
                if (!gameState.isPlaying || gameState.isPaused || !gameState.birdCanFall) return;
                
                gameState.bird.velocity += gameState.bird.gravity;
                gameState.bird.y += gameState.bird.velocity;
                
                if (gameState.bird.y < -gameState.bird.size) gameOver();
                if (gameState.bird.y + gameState.bird.size > canvas.height) {
                    gameState.bird.y = canvas.height - gameState.bird.size;
                    gameOver();
                }
            }
            draw() {
                ctx.save();
                ctx.translate(gameState.bird.x, gameState.bird.y);
                ctx.drawImage(images.bird, -gameState.bird.size/2, -gameState.bird.size/2, gameState.bird.size, gameState.bird.size);
                ctx.restore();
            }
            flap() {
                if (!gameState.isPlaying || gameState.isPaused) return;
                if (!gameState.birdCanFall) {
                    gameState.birdCanFall = true;
                    gameState.bird.velocity = 0;
                }
                gameState.bird.velocity = gameState.bird.jump;
                playFlap();
            }
        }

        // Particle effect
        class Particle {
            constructor(x, y) {
                this.x = x; this.y = y; this.size = Math.random() * 12 + 4;
                this.speedX = Math.random() * 10 - 5; this.speedY = Math.random() * 10 - 5; this.alpha = 1;
            }
            update() { this.x += this.speedX; this.y += this.speedY; this.alpha -= 0.02; }
            draw() {
                ctx.save(); 
                ctx.globalAlpha = this.alpha; 
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath(); 
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); 
                ctx.fill(); 
                ctx.restore();
            }
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            countdownElement.style.display = 'block';
            gameState.isPlaying = true;
            gameState.isPaused = false;
            gameState.birdCanFall = false;
            gameState.bird.y = canvas.height / 2;
            gameState.bird.velocity = 0;
            gameState.pipes = [];
            gameState.score = 0;
            gameState.particles = [];
            scoreDisplay.textContent = '0';
            gameOverScreen.style.display = 'none';
            pauseMenu.style.display = 'none';

            gameState.pipes.push(new Pipe());
            
            let count = 3;
            const countdownInterval = setInterval(() => {
                countdownElement.textContent = count;
                count--;
                if(count < 0) {
                    clearInterval(countdownInterval);
                    countdownElement.style.display = 'none';
                    gameState.lastPipeSpawn = Date.now();
                    gameLoop();
                }
            }, 500);
        }

        function resumeGame() {
            gameState.isPaused = false;
            pauseMenu.style.display = 'none';
            gameLoop();
        }

        function restartGame() {
            gameState.isPaused = false;
            startGame();
        }

        function gameOver() {
            if (!gameState.isPlaying) return;
            gameState.isPlaying = false;
            playHit();
            for(let i = 0; i < 50; i++) {
                gameState.particles.push(new Particle(gameState.bird.x, gameState.bird.y));
            }
            if(gameState.score > gameState.bestScore) {
                gameState.bestScore = gameState.score;
                localStorage.setItem('bestScore', gameState.bestScore);
            }
            setTimeout(() => {
                gameOverScreen.style.display = 'block';
                finalScore.textContent = gameState.score;
                bestScoreElement.textContent = gameState.bestScore;
            }, 500);
        }

        function checkCollisions() {
            const hitboxScale = -0.5;
            const halfSize = gameState.bird.size/2 * hitboxScale;
            
            const birdLeft = gameState.bird.x - halfSize;
            const birdRight = gameState.bird.x + halfSize;
            const birdTop = gameState.bird.y - halfSize;
            const birdBottom = gameState.bird.y + halfSize;

            for (const pipe of gameState.pipes) {
                const pipeRight = pipe.x + gameState.pipeWidth;
                const pipeLeft = pipe.x;
                const pipeTopBottom = pipe.topHeight;
                const pipeBottomTop = pipe.bottomY;

                const horizontalCollision = birdRight > pipeLeft && birdLeft < pipeRight;
                const verticalCollision = 
                    (birdTop < pipeTopBottom && birdBottom > 0) ||
                    (birdBottom > pipeBottomTop && birdTop < canvas.height);

                if (horizontalCollision && verticalCollision) {
                    gameOver();
                    return;
                }
            }
        }

        function spawnPipe() {
            if (Date.now() - gameState.lastPipeSpawn > 1800) {
                gameState.pipes.push(new Pipe());
                gameState.lastPipeSpawn = Date.now();
            }
        }

        function updateScore() {
            gameState.pipes.forEach(pipe => {
                if (!pipe.scored && pipe.x + gameState.pipeWidth < gameState.bird.x) {
                    pipe.scored = true;
                    gameState.score++;
                    scoreDisplay.textContent = gameState.score;
                    playPoint();
                }
            });
        }

        // Game loop
        function gameLoop() {
            if (!gameState.isPlaying || gameState.isPaused) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height);
            new Bird().update();
            gameState.pipes.forEach(pipe => pipe.update());
            gameState.particles.forEach((particle, index) => {
                particle.update();
                if(particle.alpha <= 0) gameState.particles.splice(index, 1);
            });
            checkCollisions();
            spawnPipe();
            updateScore();
            gameState.pipes = gameState.pipes.filter(pipe => pipe.x > -gameState.pipeWidth);
            gameState.pipes.forEach(pipe => pipe.draw());
            new Bird().draw();
            gameState.particles.forEach(particle => particle.draw());
            requestAnimationFrame(gameLoop);
        }

        // Controls
        document.addEventListener('keydown', (e) => { 
            if (e.code === 'Space') new Bird().flap();
            if (e.code === 'Escape') {
                gameState.isPaused = !gameState.isPaused;
                pauseMenu.style.display = gameState.isPaused ? 'block' : 'none';
            }
        });
        canvas.addEventListener('click', () => new Bird().flap());
        document.addEventListener('click', () => { 
            if (audioContext.state === 'suspended') audioContext.resume();
        }, { once: true });
    </script>
</body>
</html>
