<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird Pro</title>
    <style>
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh;
            background: #4ec0ca; font-family: 'Arial Rounded MT Bold', Arial, sans-serif; touch-action: manipulation; overflow: hidden; }
        #game-container { position: relative; width: 800px; height: 1000px; max-width: 95%; max-height: 95vh; }
        #game-canvas { width: 100%; height: 100%; }
        #score-display { 
            position: absolute; 
            top: 20px; 
            right: 20px; 
            color: white;
            font-size: 60px; 
            font-weight: bold; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); 
            z-index: 2;
        }
        #game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9);
            padding: 30px; border-radius: 20px; color: white; text-align: center; display: none; z-index: 3;
            box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        #start-screen { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; z-index: 2; color: white; }
        button { background: #f1c40f; border: none; padding: 15px 30px; border-radius: 10px; color: black;
            font-weight: bold; cursor: pointer; margin: 10px; font-size: 20px; transition: transform 0.1s; }
        button:active { transform: scale(0.95); }
        #countdown { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); 
            font-size: 100px; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); display: none; }
        #pause-menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            display: none; text-align: center; z-index: 4; }
    </style>
</head>
<body style="background-color: mediumseagreen;">
    <div id="game-container">
        <div id="start-screen">
            <h1>Flappy Bird Pro</h1>
            <button onclick="startGame()">Start Game</button>
        </div>
        <div id="score-display">Score: 0</div>
        <div id="countdown">3</div>
        <div id="pause-menu">
            <button onclick="resumeGame()">Resume</button>
            <button onclick="restartGame()">Restart</button>
        </div>
        <canvas id="game-canvas"></canvas>
        <div id="game-over">
            <h2>Game Over!</h2>
            <p>Score: <span id="final-score">0</span></p>
            <p>Best: <span id="best-score">0</span></p>
            <button onclick="startGame()">Play Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const gameOverScreen = document.getElementById('game-over');
        const finalScore = document.getElementById('final-score');
        const bestScoreElement = document.getElementById('best-score');
        const pauseMenu = document.getElementById('pause-menu');
        const countdownElement = document.getElementById('countdown');
        const startScreen = document.getElementById('start-screen');

        // Game assets
        // const images = { bird: new Image(), pipeTop: new Image(), pipeBottom: new Image(), background: new Image() };
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        const images = { 
            bird: [
                new Image(), // Frame 1 - wings up
                new Image(), // Frame 2 - wings mid
                new Image(),  // Frame 3 - wings down
                new Image(), // Frame 1 - wings up
                new Image() // Frame 2 - wings mid
              
            ], 
            layer1: new Image(),
            layer2: new Image(),
            layer3: new Image(),
            layer4: new Image(),
            pipeTop: new Image(), 
            pipeBottom: new Image(), 
            background: new Image() 
        };

        // Game state
        let gameState = { 
            bird: { 
                x: 200, 
                y: 400, 
                velocity: 0, 
                gravity: 0.5, 
                jump: -12,
                size: 100,
                rotation: 0,
                frameIndex: 0,    // New: current animation frame
                frameCounter: 0,  // New: counter for frame updates
                animationSpeed: 5 // New: frames per animation update
            },
            backgrounds: [
                { x: 0, speed: 0.2 },  // Deepest layer (slowest)
                { x: 0, speed: 0.5 },
                { x: 0, speed: 1.0 },
                { x: 0, speed: 2.0 }   // Front layer (fastest)
            ],
            pipes: [], 
            score: 0, 
            bestScore: localStorage.getItem('bestScore') || 0, 
            isPlaying: false, 
            isPaused: false, 
            lastPipeSpawn: 0, 
            pipeWidth: 200,
            gameSpeed: 2.6,
            particles: [], 
            birdCanFall: false,
            weather: {
                current: 'sunny',
                windForce: 0,
                nextChange: 0,
                particles: []
            }
        };

        // Sound functions
        function playFlap() {
            const oscillator = audioContext.createOscillator(), gainNode = audioContext.createGain();
            oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime); oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination); oscillator.start(); oscillator.stop(audioContext.currentTime + 0.1);
        }

        function playPoint() {
            const oscillator = audioContext.createOscillator(), gainNode = audioContext.createGain();
            oscillator.type = 'square'; oscillator.frequency.setValueAtTime(1500, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime); oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination); oscillator.start(); oscillator.stop(audioContext.currentTime + 0.1);
        }

        function playHit() {
            const oscillator = audioContext.createOscillator(), gainNode = audioContext.createGain();
            oscillator.type = 'square'; oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime); oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination); oscillator.start(); oscillator.stop(audioContext.currentTime + 0.6);
        }

        // Load images
        images.bird.src = 'https://iili.io/3A0Rz42.gif';
        images.pipeTop.src = 'https://iili.io/3u4luRI.md.png';
        images.pipeBottom.src = 'https://iili.io/3u4luRI.md.png';
        images.background.src = 'https://iili.io/3AWlMtR.png';

        images.layer1.src = 'https://iili.io/3AWlMtR.png';
        images.layer2.src = 'https://iili.io/3AWlMtR.png';
        images.layer3.src = 'https://iili.io/3AWlMtR.png';
        images.layer4.src = 'https://iili.io/3AWlMtR.png';


        
        // images.layer1.src = 'https://iili.io/3u4j6yG.jpg';
        // images.layer2.src = 'https://iili.io/3AEWcbf.jpg';
        // images.layer3.src = 'https://iili.io/3AEjhJt.jpg';
        // images.layer4.src = 'https://iili.io/3AEwAQf.jpg';

        // Pipe generator
        class Pipe {
            // static lastUpperLonger = false;

            constructor() {
                this.x = canvas.width;
                const minGap = 200;
                const maxGap = 300;
                this.pipeGap = minGap + Math.random() * (maxGap - minGap);
                const maxGapY = canvas.height - this.pipeGap;
                const gapY = Math.random() * maxGapY;
                
                this.topHeight = gapY;
                this.bottomY = gapY + this.pipeGap;
                this.scored = false;
            }


            update() { this.x -= gameState.gameSpeed; }
            draw() {
                // Draw top pipe from top to gap
                ctx.drawImage(images.pipeTop, this.x, 0, gameState.pipeWidth, this.topHeight);
                // Draw bottom pipe from gap to bottom
                ctx.drawImage(images.pipeBottom, this.x, this.bottomY, gameState.pipeWidth, canvas.height - this.bottomY);
            }
        }

        // Resize canvas
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            gameState.bird.y = canvas.height * 0.65;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();



        // Bird Class For Annimation

       

        images.bird[0].src = 'https://iili.io/3A0Rz42.gif'; // Wings up
        images.bird[1].src = 'https://iili.io/3A0R6js.gif'; // Wings mid
        images.bird[2].src = 'https://iili.io/3A050ts.gif'; // Wings down
        images.bird[3].src = 'https://iili.io/3A05Zxa.gif'; // Wings mid
        images.bird[4].src = 'https://iili.io/3A07Azu.gif'; // Wings down

        class Bird {


            update() {
                if (!gameState.isPlaying || gameState.isPaused || !gameState.birdCanFall) return;
                
                // Update animation frames
                gameState.bird.frameCounter++;
                if (gameState.bird.frameCounter > gameState.bird.animationSpeed) {
                    gameState.bird.frameIndex = (gameState.bird.frameIndex + 1) % 3;
                    gameState.bird.frameCounter = 0;
                }

                // Existing physics code
                gameState.bird.velocity += gameState.bird.gravity;
                gameState.bird.y += gameState.bird.velocity;
                
                // Rotation based on velocity
                //gameState.bird.rotation = Math.min(Math.PI/4, Math.max(-Math.PI/4, gameState.bird.velocity * 0.1));

                if (gameState.bird.y < -gameState.bird.size) gameOver();
                if (gameState.bird.y + gameState.bird.size > canvas.height) {
                    gameState.bird.y = canvas.height - gameState.bird.size;
                    gameOver();
                }
            }

            draw() {
                ctx.save();
                ctx.translate(gameState.bird.x, gameState.bird.y);
                // ctx.rotate(gameState.bird.rotation);
                
                // Draw current animation frame
                const currentFrame = images.bird[gameState.bird.frameIndex];
                ctx.drawImage(
                    currentFrame,
                    -gameState.bird.size/2, 
                    -gameState.bird.size/2, 
                    gameState.bird.size, 
                    gameState.bird.size
                );

                ctx.restore();
            }

            flap() {
                if (!gameState.isPlaying || gameState.isPaused) return;
                if (!gameState.birdCanFall) {
                    gameState.birdCanFall = true;
                    gameState.bird.velocity = 0;
                }
                gameState.bird.velocity = gameState.bird.jump;
                playFlap();
                
                // Reset animation frame on flap
                gameState.bird.frameIndex = 1;
                gameState.bird.frameCounter = 0;
            }
        }



        // Particle effect
        class Particle {
            constructor(x, y) {
                this.x = x; this.y = y; this.size = Math.random() * 12 + 4;
                this.speedX = Math.random() * 10 - 5; this.speedY = Math.random() * 10 - 5; this.alpha = 1;
            }
            update() { this.x += this.speedX; this.y += this.speedY; this.alpha -= 0.02; }
            draw() {
                ctx.save(); 
                ctx.globalAlpha = this.alpha; 
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath(); 
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); 
                ctx.fill(); 
                ctx.restore();
            }
        }

        function startGame() {
            startScreen.style.display = 'none';
            countdownElement.style.display = 'block';
            gameState.isPlaying = true;
            gameState.isPaused = false;
            gameState.birdCanFall = false;
            gameState.bird.y = canvas.height * 0.65;
            gameState.bird.velocity = 0;
            gameState.pipes = [];
            gameState.score = 0;
            gameState.particles = [];
            scoreDisplay.textContent = 'Score: 0';
            gameOverScreen.style.display = 'none';
            pauseMenu.style.display = 'none';

            gameState.pipes.push(new Pipe());
            
            let count = 3;
            const countdownInterval = setInterval(() => {
                countdownElement.textContent = count;
                count--;
                if(count < 0) {
                    clearInterval(countdownInterval);
                    countdownElement.style.display = 'none';
                    gameState.lastPipeSpawn = Date.now();
                    gameLoop();
                }
            }, 500);

            // new Bird().flap();
        }

        function resumeGame() {
            gameState.isPaused = false;
            pauseMenu.style.display = 'none';
            gameLoop();
        }

        function restartGame() {
            gameState.isPaused = false;
            startGame();
        }

        function gameOver() {
            if (!gameState.isPlaying) return;
            gameState.isPlaying = false;
            playHit();
            for(let i = 0; i < 50; i++) {
                gameState.particles.push(new Particle(gameState.bird.x, gameState.bird.y));
            }
            if(gameState.score > gameState.bestScore) {
                gameState.bestScore = gameState.score;
                localStorage.setItem('bestScore', gameState.bestScore);
            }
            setTimeout(() => {
                gameOverScreen.style.display = 'block';
                finalScore.textContent = gameState.score;
                bestScoreElement.textContent = gameState.bestScore;
            }, 500);
        }

        function checkCollisions() {
            const hitboxScale = -0.5;
            const halfSize = gameState.bird.size/2 * hitboxScale;
            
            const birdLeft = gameState.bird.x - halfSize;
            const birdRight = gameState.bird.x + halfSize;
            const birdTop = gameState.bird.y - halfSize;
            const birdBottom = gameState.bird.y + halfSize;

            for (const pipe of gameState.pipes) {
                const pipeRight = pipe.x + gameState.pipeWidth;
                const pipeLeft = pipe.x;
                const pipeTopBottom = pipe.topHeight;
                const pipeBottomTop = pipe.bottomY;

                const horizontalCollision = birdRight > pipeLeft && birdLeft < pipeRight;
                const verticalCollision = 
                    (birdTop < pipeTopBottom && birdBottom > 0) ||
                    (birdBottom > pipeBottomTop && birdTop < canvas.height);

                if (horizontalCollision && verticalCollision) {
                    gameOver();
                    return;
                }
            }
        }

        function spawnPipe() {
            if (Date.now() - gameState.lastPipeSpawn > 1800) {
                gameState.pipes.push(new Pipe());
                gameState.lastPipeSpawn = Date.now();
            }
        }

        function updateScore() {
            gameState.pipes.forEach(pipe => {
                if (!pipe.scored && pipe.x + gameState.pipeWidth < gameState.bird.x) {
                    pipe.scored = true;
                    gameState.score++;
                    scoreDisplay.textContent = `Score: ${gameState.score}`;
                    playPoint();
                }
            });
        }

        function updateParallax() {
            gameState.backgrounds.forEach(layer => {
                layer.x -= layer.speed;
                if (layer.x <= -canvas.width) layer.x = 0;
            });
        }
        

        // Weather particle classes
            class RainDrop {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = -10;
                    this.speed = Math.random() * 8 + 8;
                    this.size = Math.random() * 4 + 2;
                }
                update() {
                    this.y += this.speed + gameState.weather.windForce/2;
                    this.x += gameState.weather.windForce;
                    if(this.y > canvas.height) this.reset();
                }
                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = -10;
                }
                draw() {
                    ctx.fillStyle = 'rgba(150, 200, 255, 0.7)';
                    ctx.fillRect(this.x, this.y, 2, this.size*2);
                }
            }

            class SnowFlake {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = -10;
                    this.speed = Math.random() * 2 + 1;
                    this.size = Math.random() * 3 + 2;
                    this.angle = Math.random() * Math.PI * 2;
                }
                update() {
                    this.y += this.speed;
                    this.x += Math.sin(this.angle * 0.5) * 1.5 + gameState.weather.windForce;
                    this.angle += 0.02;
                    if(this.y > canvas.height) this.reset();
                }
                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = -10;
                }
                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fill();
                }
            }


        // Weather system functions
        function updateWeather() {
            //debugger;
                if(Date.now() > gameState.weather.nextChange) {
                    const weatherTypes = ['sunny', 'rain', 'snow', 'windy'];
                    gameState.weather.current = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
                    gameState.weather.nextChange = Date.now() + 2000 + Math.random() * 2000;
                    gameState.weather.windForce = gameState.weather.current === 'windy' ? (Math.random() * 2 - 1) : 0;
                    
                    // Clear existing weather particles when changing
                    gameState.weather.particles = [];
                    
                    // Initialize new particles
                    if(gameState.weather.current === 'rain') {
                        for(let i = 0; i < 100; i++) gameState.weather.particles.push(new RainDrop());
                    }
                    if(gameState.weather.current === 'snow') {
                        for(let i = 0; i < 50; i++) gameState.weather.particles.push(new SnowFlake());
                    }
                }
        }


        // Game loop
        function gameLoop() {
            //debugger;
            if (!gameState.isPlaying || gameState.isPaused) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw background with reduced height (90% of canvas height)
                const bgHeight = canvas.height * 0.9;
                const bgY = (canvas.height - bgHeight) / 2;
                ctx.drawImage(images.background, 0, bgY, canvas.width, bgHeight);

            // Draw parallax layers
             gameState.backgrounds.forEach((layer, index) => {
                const img = images[`layer${index + 1}`];
                ctx.drawImage(img, layer.x, 0, canvas.width, canvas.height);
                ctx.drawImage(img, layer.x + canvas.width, 0, canvas.width, canvas.height);
            });

            updateParallax();



            new Bird().update();
            updateWeather();   // This line is added by myself
            gameState.weather.particles.forEach(p => {
                p.update();
                p.draw();
            });

            gameState.pipes.forEach(pipe => pipe.update());
            gameState.particles.forEach((particle, index) => {
                particle.update();
                if(particle.alpha <= 0) gameState.particles.splice(index, 1);
            });
            checkCollisions();
            spawnPipe();
            updateScore();
            gameState.pipes = gameState.pipes.filter(pipe => pipe.x > -gameState.pipeWidth);
            gameState.pipes.forEach(pipe => pipe.draw());
            new Bird().draw();
            gameState.particles.forEach(particle => particle.draw());

  
            requestAnimationFrame(gameLoop);
        }

        // Controls
        document.addEventListener('keydown', (e) => { 
            if (e.code === 'Space') {
                if (gameState.isPlaying) {
                    new Bird().flap();
                } else if (gameOverScreen.style.display === 'block') {
                    startGame();
                } else if (startScreen.style.display !== 'none') {
                    startGame();
                }
            }
            if (e.code === 'Escape') {
                gameState.isPaused = !gameState.isPaused;
                pauseMenu.style.display = gameState.isPaused ? 'block' : 'none';
            }
        });
        canvas.addEventListener('click', () => {
            if (gameState.isPlaying) {
                new Bird().flap();
            } else if (gameOverScreen.style.display === 'block') {
                startGame();
            }
        });
        document.addEventListener('click', () => { 
            if (audioContext.state === 'suspended') audioContext.resume();
        }, { once: true });
    </script>


      <!-- Particle Effects for Visual Flair (Add sparks when collecting points or hitting pipes) -->
    <script>
        // ... (keep existing game state and asset declarations unchanged) ... 

        // Enhanced Particle class with configurable properties
        // class Particle {
        //     constructor(x, y, color = '#f1c40f', size = Math.random() * 12 + 4, speedMultiplier = 1, decayRate = 0.02) {
        //         this.x = x;
        //         this.y = y;
        //         this.size = size;
        //         this.speedX = (Math.random() * 10 - 5) * speedMultiplier;
        //         this.speedY = (Math.random() * 10 - 5) * speedMultiplier;
        //         this.alpha = 1;
        //         this.color = color;
        //         this.decayRate = decayRate;
        //     }
        //     update() { 
        //         this.x += this.speedX; 
        //         this.y += this.speedY; 
        //         this.alpha -= this.decayRate; 
        //     }
        //     draw() {
        //         ctx.save(); 
        //         ctx.globalAlpha = this.alpha; 
        //         ctx.fillStyle = this.color;
        //         ctx.beginPath(); 
        //         ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); 
        //         ctx.fill(); 
        //         ctx.restore();
        //     }
        // }

        // Modified score handling with golden sparks
        function updateScore() {
            gameState.pipes.forEach(pipe => {
                if (!pipe.scored && pipe.x + gameState.pipeWidth < gameState.bird.x) {
                    pipe.scored = true;
                    gameState.score++;
                    scoreDisplay.textContent = `Score: ${gameState.score}`;
                    playPoint();
                    
                    // Add golden score particles
                    for (let i = 0; i < 10; i++) {
                        gameState.particles.push(new Particle(
                            gameState.bird.x,
                            gameState.bird.y,
                            '#FFD700', // Gold color
                            Math.random() * 4 + 2, // Size between 2-6
                            2, // Speed multiplier
                            0.05 // Faster decay
                        ));
                    }
                }
            });
        }

        // Enhanced collision detection with impact particles
        function checkCollisions() {
            const hitboxScale = -0.5;
            const halfSize = gameState.bird.size/2 * hitboxScale;
            
            const birdLeft = gameState.bird.x - halfSize;
            const birdRight = gameState.bird.x + halfSize;
            const birdTop = gameState.bird.y - halfSize;
            const birdBottom = gameState.bird.y + halfSize;

            for (const pipe of gameState.pipes) {
                const pipeRight = pipe.x + gameState.pipeWidth;
                const pipeLeft = pipe.x;
                const pipeTopBottom = pipe.topHeight;
                const pipeBottomTop = pipe.bottomY;

                const horizontalCollision = birdRight > pipeLeft && birdLeft < pipeRight;
                const verticalCollision = 
                    (birdTop < pipeTopBottom && birdBottom > 0) ||
                    (birdBottom > pipeBottomTop && birdTop < canvas.height);

                if (horizontalCollision && verticalCollision) {
                    // Add red impact particles
                    for (let i = 0; i < 20; i++) {
                        gameState.particles.push(new Particle(
                            gameState.bird.x,
                            gameState.bird.y,
                            '#FF4500', // Orange-red color
                            Math.random() * 6 + 3, // Size between 3-9
                            1.5, // Speed multiplier
                            0.05 // Faster decay
                        ));
                    }
                    gameOver();
                    return;
                }
            }
        }

        // ... (keep remaining existing JavaScript code unchanged) ...
    </script>

    <script>
    

        // Weather particle classes
        class RainDrop123 {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = -10;
                this.speed = Math.random() * 8 + 8;
                this.size = Math.random() * 4 + 2;
            }
            update() {
                this.y += this.speed + gameState.weather.windForce/2;
                this.x += gameState.weather.windForce;
                if(this.y > canvas.height) this.reset();
            }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = -10;
            }
            draw() {
                ctx.fillStyle = 'rgba(150, 200, 255, 0.7)';
                ctx.fillRect(this.x, this.y, 2, this.size*2);
            }
        }

        class SnowFlake123 {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = -10;
                this.speed = Math.random() * 2 + 1;
                this.size = Math.random() * 3 + 2;
                this.angle = Math.random() * Math.PI * 2;
            }
            update() {
                this.y += this.speed;
                this.x += Math.sin(this.angle * 0.5) * 1.5 + gameState.weather.windForce;
                this.angle += 0.02;
                if(this.y > canvas.height) this.reset();
            }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = -10;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fill();
            }
        }

        // Weather system functions
        function updateWeather123() {
            if(Date.now() > gameState.weather.nextChange) {
                const weatherTypes = ['sunny', 'rain', 'snow', 'windy'];
                gameState.weather.current = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
                gameState.weather.nextChange = Date.now() + 500 + Math.random() * 500;
                gameState.weather.windForce = gameState.weather.current === 'windy' ? (Math.random() * 2 - 1) : 0;
                
                // Clear existing weather particles when changing
                gameState.weather.particles = [];
                
                // Initialize new particles
                if(gameState.weather.current === 'rain') {
                    for(let i = 0; i < 100; i++) gameState.weather.particles.push(new RainDrop());
                }
                if(gameState.weather.current === 'snow') {
                    for(let i = 0; i < 50; i++) gameState.weather.particles.push(new SnowFlake());
                }
            }
        }

        // Modified Bird class with wind effects
        class Bird {
            
            update() {
                if (!gameState.isPlaying || gameState.isPaused || !gameState.birdCanFall) return;
                
                // Apply wind force
                gameState.bird.x += gameState.weather.windForce;
                gameState.bird.velocity += gameState.bird.gravity + (gameState.weather.windForce * 0.1);
                
                // Keep bird in bounds horizontally
                gameState.bird.x = Math.max(gameState.bird.size/2, 
                    Math.min(canvas.width - gameState.bird.size/2, gameState.bird.x));
                
                // ... (rest of existing update code) ...
            }
            // ... (keep rest of Bird class unchanged) ...
        }

        // Modified game loop to include weather
        function gameLoop() {
            //debugger;
            if (!gameState.isPlaying || gameState.isPaused) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height);
            
            // Update and draw weather
            updateWeather();
            gameState.weather.particles.forEach(p => {
                p.update();
                p.draw();
            });

            // ... (rest of existing game loop code) ...
            
            requestAnimationFrame(gameLoop);
        }

        // ... (keep remaining existing JavaScript code unchanged) ...

        // Initialize weather system
        gameState.weather.nextChange = Date.now() + 1000;
    </script>

    <script>
        // ... (all previous JavaScript code remains unchanged until updateScore function) ...

        function updateScore() {
            gameState.pipes.forEach(pipe => {
                if (!pipe.scored && pipe.x + gameState.pipeWidth < gameState.bird.x) {
                    pipe.scored = true;
                    gameState.score++;
                    scoreDisplay.textContent = `Score: ${gameState.score}`;
                    playPoint();
                    
                    // Add golden score particles
                    for (let i = 0; i < 10; i++) {
                        gameState.particles.push(new Particle(
                            gameState.bird.x,
                            gameState.bird.y,
                            '#FFD700',
                            Math.random() * 4 + 2,
                            2,
                            0.05
                        ));
                    }
                }
            });
        }  // Added missing closing brace

        // ... (remaining existing JavaScript code unchanged) ...

        // Initialize weather system
        gameState.weather.nextChange = Date.now() + 1000;

        // Ensure all functions are properly defined in global scope
        window.startGame = startGame;
        window.resumeGame = resumeGame;
        window.restartGame = restartGame;
    </script>
    



</body>
</html>


<!-- In the above code , background image is scrolling , but background image changing effect should not feel, enhance that background image changing effect should not feel. keep remaining code as it is and give me code in single file -->