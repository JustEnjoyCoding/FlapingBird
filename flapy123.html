<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird Pro</title>

      <!-- Google Analytics -->
    <!-- <script async src="https://www.googletagmanager.com/gtag/js?id=GA_MEASUREMENT_ID"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'GA_MEASUREMENT_ID');
    </script> -->

    <!-- Google Adsense -->
    <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=AD_CLIENT_ID"
            crossorigin="anonymous">
    </script> -->

    <!-- This code is used to prevent access view source code -->
    <!-- <script>
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });
        
        document.onkeydown = function(e) {
            if(e.keyCode == 123) { // Disable F12
                return false;
            }
            if(e.ctrlKey && e.shiftKey && e.keyCode == 'I'.charCodeAt(0)) { // Disable Ctrl+Shift+I
                return false;
            }
            if(e.ctrlKey && e.shiftKey && e.keyCode == 'J'.charCodeAt(0)) { // Disable Ctrl+Shift+J
                return false;
            }
            if(e.ctrlKey && e.keyCode == 'U'.charCodeAt(0)) { // Disable Ctrl+U
                return false;
            }
        };
    </script> -->

    <style>
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh;
            background: #4ec0ca; font-family: 'Arial Rounded MT Bold', Arial, sans-serif; touch-action: manipulation; overflow: hidden;
            
              
        
        }
        #game-container { position: relative; width: 800px; height: 1000px; max-width: 95%; max-height: 95vh; }

        #game-canvas { 
            width: 100%; height: 100%; 
            border: 5px solid white; /* Added white border */
            border-radius: 15px; /* Add this */
            overflow: hidden; /* Ensures content respects the border radius */
            background-image: url('https://iili.io/35sfcFe.jpg');
            background-size: cover;
            background-position: center;
        
            
        }

        #score-display { 
            position: absolute; 
            top: 20px; 
            right: 20px; 
            color: white;
            font-size: 30px;
            font-weight: bold; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); 
            z-index: 2;
            background: rgba(241, 196, 15, 0.9);
            border-radius: 15px;
            padding: 10px 18px;
            box-shadow: 0 0 8px rgba(0,0,0,0.3);
            min-width: 140px;
            text-align: center;
            border: 3px solid white; /* Added white border */
            display: none; /* Hidden by default */
        }

        #score-display.visible {
            display: block; /* Show when needed */
        }

        #game-over { 
                position: absolute; 
                top: 50%; 
                left: 50%; 
                transform: translate(-50%, -50%); 
                background: lightseagreen;
                padding: 30px; 
                border-radius: 20px; 
                color: white; 
                text-align: center; 
                display: none; 
                z-index: 3;
                box-shadow: 0 0 30px rgba(0,0,0,0.5); 
                width: 80%;
                max-width: 400px;
                border: 3px solid white; /* Added white border */
        }
        #start-screen { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; z-index: 2; color: white; }

        button { 
                        background: #f1c40f; 
                        border: none; 
                        padding: 15px 30px; 
                        border-radius: 10px; 
                        color: black;
                        font-weight: bold; 
                        cursor: pointer; 
                        margin: 10px; 
                        font-size: 20px; 
                        transition: transform 0.1s; 
                        min-width: 200px;
                        /* border: 2px solid white;  */
               }

        button:active { transform: scale(0.95); }

        /* #countdown { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); 
            font-size: 100px; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); display: none; } */

        /* Updated pause menu styles */
        #pause-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            text-align: center;
            z-index: 4;
            background: navy;
            border-radius: 20px;
            padding: 25px;
            border: 2px solid white;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* Mobile optimization */
        @media (max-width: 600px) {
            #pause-menu {
                padding: 20px;
                border-radius: 15px;
                width: 80%;
                max-width: 300px;
            }
            
            #pause-menu button {
                font-size: 16px;
                padding: 12px 20px;
            }
        }



        #countdown { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 100px; 
            color: white; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            width: 150px;
            height: 150px;
            text-align: center;
            line-height: 150px;
            display:none;
            z-index: 5;
        }
        
        #countdown::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 150px;
            height: 150px;
            border: 5px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            border-top-color: white;
            animation: rotate 1s linear infinite;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
        }
        #countdown::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 130px;
            height: 130px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
        }
        @keyframes rotate {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

   
       
        #game-container { position: relative; width: 800px; height: 1000px; max-width: 95%; max-height: 95vh; }
 
        /* New Ad styling */
        .ad-container {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 160px;
            z-index: 100;
        }
        #left-ad { left: 10px; }
        #right-ad { right: 10px; }

    
        /* Add leaderboard styles */
        #leaderboard {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: navy;
            color: white;
            padding: 20px;
            border-radius: 15px;
            width: 300px;
            max-width: 90%;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 3px solid white; /* Added white border */
        }
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }
        #submit-form {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: navy;
            padding: 25px;
            border-radius: 15px;
            color: white;
            display: none;
            z-index: 1001;
            text-align: center;
            width: 90%;
            max-width: 400px;
            border: 3px solid white; /* Added white border */
        }
        #submit-form input {
            display: block;
            margin: 15px auto;
            padding: 12px;
            width: 90%;
            border-radius: 8px;
            border: none;
            font-size: 16px;
        }

        #submit-form button {
            flex: 1;
            padding: 12px;
            margin: 0;
            font-size: 16px;
            min-width: auto;
        }

        #submit-form .button-container {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }
        /* Add to existing game-over style */
        #game-over button { 
            width: 100%;
            box-sizing: border-box;
            margin: 8px 0;
            padding: 12px 20px;
        }

        #leaderboard button {
            margin: 15px auto 0;
            padding: 10px 25px;
            font-size: 16px;
            display: block;
            width: auto;
        }

        /* Add this to your existing CSS */
        #score-display.hidden {
            display: none;
        }

        @media (max-width: 600px) {
            #submit-form {
                padding: 20px;
                width: 85%;
                border: 2px solid white; /* Thinner border for mobile */
            }
            
            /* #submit-form input {
                padding: 10px;
                font-size: 14px;
                margin: 10px auto;
            }
            
            #submit-form .button-container {
                flex-direction: column;
                gap: 8px;
            }
            
            #submit-form button {
                width: 100%;
                padding: 10px;
                font-size: 14px;
            } */

            #submit-form .button-container {
                flex-direction: row; /* Keep buttons in row */
                gap: 8px;
                flex-wrap: wrap; /* Allow wrapping if needed */
                justify-content: center;
            }
    
            #submit-form button {
                flex: 1; /* Equal width buttons */
                min-width: 120px; /* Minimum touch target size */
                padding: 10px;
                font-size: 14px;
            }
    
            /* Adjust input fields for better mobile display */
            #submit-form input {
                padding: 12px;
                font-size: 16px;
            }
        }

        @media (max-width: 600px) {
            button {
                font-size: 16px;
                padding: 12px 20px;
                min-width: auto;
                width: 100%;
                margin: 6px 0;
            }
            
            #game-over {
                padding: 20px;
                width: 90%;
                border: 2px solid white; /* Thinner border for mobile */
            }
            
            #score-display {
                font-size: 40px;
                right: 10px;
                top: 10px;
            }
        }

        @media (max-width: 600px) {
            #leaderboard {
                padding: 15px;
                width: 85%;
                border: 2px solid white; /* Thinner border for mobile */
            }
            
            #leaderboard button {
                padding: 8px 20px;
                font-size: 14px;
                margin: 12px auto 0;
            }
            
            .leaderboard-entry {
                font-size: 14px;
                padding: 6px;
            }
            
            #leaderboard h2 {
                font-size: 20px;
                margin: 0 0 12px 0;
            }
        }

        @media (max-width: 600px) {
            #score-display {
                font-size: 30px;
                padding: 6px 12px;
                border-radius: 12px;
                min-width: 100px;
                top: 12px;
                right: 12px;
                border: 2px solid white; /* Thinner border for mobile */
            }
        }

    /* Loading spinner styles */
    .loading-spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #f1c40f;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 20px auto;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .leaderboard-content {
        display: none;
    }
    
    .loading .leaderboard-content {
        display: block;
    }
    
    .loading .loading-spinner {
        display: block;
    }

      /* Add this to your existing button styles */
      #start-screen button {
        border: 4px solid white;
        box-sizing: border-box; /* Ensures border doesn't affect button size */
    }

    /* Optional: Add hover effect */
    #start-screen button:hover {
        border-color: #0ad615;
    }
    </style>


</head>
<body style="background-color: mediumseagreen;">
    

    <!-- Left Ad -->
    <!-- <div class="ad-container" id="left-ad">
        
        <ins class="adsbygoogle"
             style="display:flexbox"
             data-ad-client="AD_CLIENT_ID"
             data-ad-slot="LEFT_AD_SLOT_ID"
             data-ad-format="auto"
             data-full-width-responsive="true"></ins>
        <script>
             (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
    </div> -->



    <!-- Game Container -->
    <div id="game-container">
        <div id="start-screen">
            <h1></h1>
            <button style="margin-top: 146px;" onclick="startGame()">Start Game</button>
        </div>
        <div id="score-display" style="background-color: lightseagreen;">Score: 0</div>
        <div id="countdown">3</div>
        <div id="pause-menu">
            <button onclick="resumeGame()">Resume</button>
            <button onclick="restartGame()">Restart</button>
        </div>
        <canvas id="game-canvas"></canvas>

        <div id="game-over">
            <h2>Game Over!</h2>
            <p>Score: <span id="final-score">0</span></p>
            <button onclick="startGame()">Play Again</button>
            <button onclick="showSubmitForm()">Submit Score</button>
            <button onclick="showLeaderboard()">View Leaderboard</button>
        </div>

        <!-- Leaderboard and Submit Form -->
        <div id="leaderboard">
            <h2>🏆 Leaderboard</h2>
            <div class="loading-spinner"></div>
            <div class="leaderboard-content">
                <div id="leaderboard-entries"></div>
                <button onclick="hideLeaderboard()" style="margin-top: 15px;">Close</button>
            </div>
        </div>

        <div id="submit-form">
            <h3>New High Score! 🎉</h3>
            <input type="text" id="player-name" placeholder="Your Name" style="text-transform: uppercase" required>
            <input type="text" id="player-country" placeholder="Country code in 2 letter" 
                   maxlength="2" style="text-transform: uppercase">
            <div class="button-container" style="padding: 20px;">
                <button onclick="submitScore()">Submit</button>
                <button onclick="hideSubmitForm()">Cancel</button>
            </div>
        </div>

    </div>

     <!-- Right Ad -->
     <!-- <div class="ad-container" id="right-ad">
        
        <ins class="adsbygoogle"
             style="display:flexbox"
             data-ad-client="AD_CLIENT_ID"
             data-ad-slot="RIGHT_AD_SLOT_ID"
             data-ad-format="auto"
             data-full-width-responsive="true"></ins>
        <script>
             (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
    </div> -->



    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const gameOverScreen = document.getElementById('game-over');
        const finalScore = document.getElementById('final-score');
        const bestScoreElement = document.getElementById('best-score');
        const pauseMenu = document.getElementById('pause-menu');
        const countdownElement = document.getElementById('countdown');
        const startScreen = document.getElementById('start-screen');
        // Configuration
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbxzg2e2KGC1d8Hel-9KbHYTZ2SuiSrcnzh9N45yYEGofQZ_1i-q957TzibI7unZ-Qw9/exec'; // Replace with your URL
        
        const backgroundImage = new Image();
        backgroundImage.src = 'https://iili.io/35sfcFe.jpg';

        // Game assets
        // const images = { bird: new Image(), pipeTop: new Image(), pipeBottom: new Image(), background: new Image() };
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        const images = { 
            bird: [
                new Image(), // Frame 1 - wings up
                new Image(), // Frame 2 - wings mid
                new Image(),  // Frame 3 - wings down
                new Image(), // Frame 1 - wings up
                new Image() // Frame 2 - wings mid
              
            ], 
            layer1: new Image(),
            layer2: new Image(),
            layer3: new Image(),
            layer4: new Image(),
            pipeTop: new Image(), 
            pipeBottom: new Image(), 
            background: new Image() 
        };

        // Game state
        let gameState = { 
            bird: { 
                x: 200, 
                y: 400, 
                velocity: 2, 
                gravity: 0.5, 
                jump: -12,
                size: 100,
                rotation: 0,
                frameIndex: 0,    // New: current animation frame
                frameCounter: 0,  // New: counter for frame updates
                animationSpeed: 5 // New: frames per animation update
            },
            backgrounds: [
                { x: 0, speed: 1.0 },  // Deepest layer (slowest)
                { x: 0, speed: 1.5 },
                { x: 0, speed: 2.0 },
                { x: 0, speed: 2.5 }   // Front layer (fastest)
            ],
            pipes: [], 
            score: 0, 
            bestScore: localStorage.getItem('bestScore') || 0, 
            isPlaying: false, 
            isPaused: false, 
            lastPipeSpawn: 0, 
            pipeWidth: 200,
            gameSpeed: 2.6,
            particles: [], 
            birdCanFall: false,
            weather: {
                current: 'sunny',
                windForce: 0,
                nextChange: 0,
                particles: []
            }
        };

        // Sound functions
        function playFlap() {
            const oscillator = audioContext.createOscillator(), gainNode = audioContext.createGain();
            oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime); oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination); oscillator.start(); oscillator.stop(audioContext.currentTime + 0.1);
        }

        function playPoint() {
            const oscillator = audioContext.createOscillator(), gainNode = audioContext.createGain();
            oscillator.type = 'square'; oscillator.frequency.setValueAtTime(1500, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime); oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination); oscillator.start(); oscillator.stop(audioContext.currentTime + 0.1);
        }

        function playHit() {
            const oscillator = audioContext.createOscillator(), gainNode = audioContext.createGain();
            oscillator.type = 'square'; oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime); oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination); oscillator.start(); oscillator.stop(audioContext.currentTime + 0.6);
        }

        // Load images
        images.bird.src = 'https://iili.io/3A0Rz42.gif';
        images.pipeTop.src = 'https://iili.io/3u4luRI.md.png';
        images.pipeBottom.src = 'https://iili.io/3u4luRI.md.png';
        images.background.src = 'https://iili.io/3AWlMtR.png';

        images.layer1.src = 'https://iili.io/3AWlMtR.png';
        images.layer2.src = 'https://iili.io/3AWlMtR.png';
        images.layer3.src = 'https://iili.io/3AWlMtR.png';
        images.layer4.src = 'https://iili.io/3AWlMtR.png';



        
        // images.layer1.src = 'https://iili.io/3u4j6yG.jpg';
        // images.layer2.src = 'https://iili.io/3AEWcbf.jpg';
        // images.layer3.src = 'https://iili.io/3AEjhJt.jpg';
        // images.layer4.src = 'https://iili.io/3AEwAQf.jpg';


       

        // Pipe generator
        class Pipe {
            // static lastUpperLonger = false;

            constructor() {
                this.x = canvas.width;
                const minGap = 200;
                const maxGap = 300;
                this.pipeGap = minGap + Math.random() * (maxGap - minGap);
                const maxGapY = canvas.height - this.pipeGap;
                const gapY = Math.random() * maxGapY;
                
                this.topHeight = gapY;
                this.bottomY = gapY + this.pipeGap;
                this.scored = false;
            }


            update() { this.x -= gameState.gameSpeed; }
            draw() {
                // Draw top pipe from top to gap
                ctx.drawImage(images.pipeTop, this.x, 0, gameState.pipeWidth, this.topHeight);
                // Draw bottom pipe from gap to bottom
                ctx.drawImage(images.pipeBottom, this.x, this.bottomY, gameState.pipeWidth, canvas.height - this.bottomY);
            }
        }

        // Resize canvas
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            gameState.bird.y = canvas.height * 0.65;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();



        // Bird Class For Annimation

       

        images.bird[0].src = 'https://iili.io/3A0Rz42.gif'; // Wings up
        images.bird[1].src = 'https://iili.io/3A0R6js.gif'; // Wings mid
        images.bird[2].src = 'https://iili.io/3A050ts.gif'; // Wings down
        images.bird[3].src = 'https://iili.io/3A05Zxa.gif'; // Wings mid
        images.bird[4].src = 'https://iili.io/3A07Azu.gif'; // Wings down

        // Add special animation state
        gameState.specialAnimation = {
            active: false,
            framesRemaining: 0
        };

        // Add Emoji Particle class
        class EmojiParticle {
            constructor(x, y, emoji, color) {
                this.x = x;
                this.y = y;
                this.emoji = emoji;
                this.color = color;
                this.size = Math.random() * 20 + 15;
                this.speedX = (Math.random() - 0.5) * 4;
                this.speedY = (Math.random() - 1) * 5;
                this.alpha = 1;
                this.decayRate = 0.02;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.alpha -= this.decayRate;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.font = `${this.size}px Arial`;
                ctx.fillStyle = this.color;
                ctx.fillText(this.emoji, this.x, this.y);
                ctx.restore();
            }
        }

        class Bird {


            update() {
                if (!gameState.isPlaying || gameState.isPaused || !gameState.birdCanFall) return;
                
                // Update animation frames
                gameState.bird.frameCounter++;
                if (gameState.bird.frameCounter > gameState.bird.animationSpeed) {
                    gameState.bird.frameIndex = (gameState.bird.frameIndex + 1) % 3;
                    gameState.bird.frameCounter = 0;
                }

                // Existing physics code
                gameState.bird.velocity += gameState.bird.gravity;
                gameState.bird.y += gameState.bird.velocity;
                
                // Rotation based on velocity
                //gameState.bird.rotation = Math.min(Math.PI/4, Math.max(-Math.PI/4, gameState.bird.velocity * 0.1));

                if (gameState.bird.y < -gameState.bird.size) gameOver();
                if (gameState.bird.y + gameState.bird.size > canvas.height) {
                    gameState.bird.y = canvas.height - gameState.bird.size;
                    gameOver();
                }
            }

            draw() {
                ctx.save();
                ctx.translate(gameState.bird.x, gameState.bird.y);
                // ctx.rotate(gameState.bird.rotation);
                
                if (gameState.specialAnimation.active) {
                    ctx.rotate(0); // Face forward
                } else {
                    ctx.rotate(gameState.bird.rotation);
                }

               
                // Draw current animation frame
                const currentFrame = images.bird[gameState.bird.frameIndex];
                ctx.drawImage(
                    currentFrame,
                    -gameState.bird.size/2, 
                    -gameState.bird.size/2, 
                    gameState.bird.size, 
                    gameState.bird.size
                );


                ctx.restore();
                
                // Draw kiss emoji during special animation
                if (gameState.specialAnimation.active) {
                    ctx.save();
                    ctx.font = '40px Arial';
                    ctx.fillStyle = '#FF69B4';
                    ctx.fillText('😘', gameState.bird.x + 50, gameState.bird.y - 50);
                    ctx.restore();
                }


            }

            flap() {
                if (!gameState.isPlaying || gameState.isPaused) return;
                if (!gameState.birdCanFall) {
                    gameState.birdCanFall = true;
                    gameState.bird.velocity = 0;
                }
                gameState.bird.velocity = gameState.bird.jump;
                playFlap();
                
                // Reset animation frame on flap
                gameState.bird.frameIndex = 1;
                gameState.bird.frameCounter = 0;
            }
        }



        // Particle effect
        class Particle {
            constructor(x, y) {
                this.x = x; this.y = y; this.size = Math.random() * 12 + 4;
                this.speedX = Math.random() * 10 - 5; this.speedY = Math.random() * 10 - 5; this.alpha = 1;
            }
            update() { this.x += this.speedX; this.y += this.speedY; this.alpha -= 0.02; }
            draw() {
                ctx.save(); 
                ctx.globalAlpha = this.alpha; 
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath(); 
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); 
                ctx.fill(); 
                ctx.restore();
            }
        }



         // Enhanced Leaderboard Functions
         async function submitScore() {
            debugger;
            const name = document.getElementById('player-name').value.trim();
            const country = document.getElementById('player-country').value.trim().toUpperCase();

            if (!name || !country || country.length !== 2 || !/^[A-Za-z]{2}$/.test(country)) {
                alert('Please Enter valid country name');
                return;
            }

            try {
                const response = await fetch(SCRIPT_URL, {
                    method: 'POST',
                    mode: 'cors',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({
                        name: name,
                        score: gameState.score,
                        country: country,
                        timestamp: new Date().toISOString()
                    })
                });

                if (!response.ok) throw new Error('Submission failed');
                
                // Clear inputs after successful submission
                name.value = '';
                country.value = '';

                hideSubmitForm();
                showLeaderboard();
                //alert('Score submitted successfully!');
            } catch (error) {
                console.error('Submission error:', error);
                alert('Failed to submit score. Please try again.');
            }
        }

        async function showLeaderboard() {
            try {
                //debugger;
                const leaderboard = document.getElementById('leaderboard');
                const spinner = leaderboard.querySelector('.loading-spinner');
                const content = leaderboard.querySelector('.leaderboard-content');
                
                // Show loading
                leaderboard.style.display = 'block';
                spinner.style.display = 'block';
                content.style.display = 'none';

                const response = await fetch(SCRIPT_URL);
                if (!response.ok) throw new Error('Network error');
                const data = await response.json();
                
                const entries = data
                .sort((a, b) => b.score - a.score)
                .slice(0, 10)
                .map((entry, index) => `
                    <div class="leaderboard-entry">
                    <span>${index + 1}. ${entry.name}</span>
                    <span>${entry.score} (${entry.country})</span>
                    </div>
                `).join('');

                document.getElementById('leaderboard-entries').innerHTML = entries;
                document.getElementById('leaderboard').style.display = 'block';
                // Show content
                spinner.style.display = 'none';
                content.style.display = 'block';

            } catch (error) {
                console.error('Leaderboard error:', error);
                spinner.style.display = 'none';
                alert('Failed to load leaderboard. Please try again.');
            }
        }

     
        function showSubmitForm() {
            document.getElementById('submit-form').style.display = 'block';
            document.getElementById('game-over').style.display = 'none';
        }

        function hideSubmitForm() {
            document.getElementById('submit-form').style.display = 'none';
            document.getElementById('game-over').style.display = 'block';
        }

        function hideLeaderboard() {
            document.getElementById('leaderboard').style.display = 'none';
           
        }

        




        function startGame() {
            startScreen.style.display = 'none';
            countdownElement.style.display = 'block';
            gameState.isPlaying = true;
            gameState.isPaused = false;
            gameState.birdCanFall = false;
            gameState.bird.y = canvas.height * 0.65;
            gameState.bird.velocity = 0;
            gameState.pipes = [];
            gameState.score = 0;
            gameState.particles = [];
            scoreDisplay.textContent = 'Score: 0';
            gameOverScreen.style.display = 'none';
            pauseMenu.style.display = 'none';

             // Show score display
            document.getElementById('score-display').classList.remove('hidden');
            document.getElementById('score-display').classList.add('visible'); // Show score

            startScreen.style.display = 'none';
            countdownElement.style.display = 'block';

            gameState.pipes.push(new Pipe());

           
            
            let count = 3;
            const countdownInterval = setInterval(() => {
                countdownElement.textContent = count;
                count--;
                if(count < 0) {
                    clearInterval(countdownInterval);
                    countdownElement.style.display = 'none';
                    gameState.lastPipeSpawn = Date.now();
                    gameLoop();
                }
            }, 500);


            

            // new Bird().flap();
        }

        function resumeGame() {
            document.getElementById('score-display').classList.add('visible'); // Show score
            gameState.isPaused = false;
            pauseMenu.style.display = 'none';
            gameLoop();
        }

        function restartGame() {
            document.getElementById('score-display').classList.add('visible'); // Show score
            gameState.isPaused = false;
            startGame();
        }

         // Modified gameOver function
         function gameOver() {
            if (!gameState.isPlaying) return;
            gameState.isPlaying = false;
            playHit();

            document.getElementById('score-display').classList.add('hidden');
            document.getElementById('score-display').classList.remove('visible'); // Hide score

            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').textContent = gameState.score;
            
            if (gameState.score > gameState.bestScore) {
                gameState.bestScore = gameState.score;
                localStorage.setItem('bestScore', gameState.bestScore);
            }
            bestScoreElement.textContent = gameState.bestScore;
            
        }

        function checkCollisions() {
            const hitboxScale = -0.5;
            const halfSize = gameState.bird.size/2 * hitboxScale;
            
            const birdLeft = gameState.bird.x - halfSize;
            const birdRight = gameState.bird.x + halfSize;
            const birdTop = gameState.bird.y - halfSize;
            const birdBottom = gameState.bird.y + halfSize;

            for (const pipe of gameState.pipes) {
                const pipeRight = pipe.x + gameState.pipeWidth;
                const pipeLeft = pipe.x;
                const pipeTopBottom = pipe.topHeight;
                const pipeBottomTop = pipe.bottomY;

                const horizontalCollision = birdRight > pipeLeft && birdLeft < pipeRight;
                const verticalCollision = 
                    (birdTop < pipeTopBottom && birdBottom > 0) ||
                    (birdBottom > pipeBottomTop && birdTop < canvas.height);

                if (horizontalCollision && verticalCollision) {
                    gameOver();
                    return;
                }
            }
        }

        function spawnPipe() {
            if (Date.now() - gameState.lastPipeSpawn > 1800) {
                gameState.pipes.push(new Pipe());
                gameState.lastPipeSpawn = Date.now();
            }
        }

        function updateScore() {
            gameState.pipes.forEach(pipe => {
                if (!pipe.scored && pipe.x + gameState.pipeWidth < gameState.bird.x) {
                    pipe.scored = true;
                    gameState.score++;
                    scoreDisplay.textContent = `Score: ${gameState.score}`;
                    playPoint();
                }
            });
        }

        function updateParallax() {
            gameState.backgrounds.forEach(layer => {
                layer.x -= layer.speed;
                if (layer.x <= -canvas.width) layer.x = 0;
            });
        }
        

        // Weather particle classes
            class RainDrop {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = -10;
                    this.speed = Math.random() * 8 + 8;
                    this.size = Math.random() * 6 + 4;
                }
                update() {
                    this.y += this.speed + gameState.weather.windForce/2;
                    this.x += gameState.weather.windForce;
                    if(this.y > canvas.height) this.reset();
                }
                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = -10;
                }
                draw() {
                    ctx.fillStyle = 'rgba(150, 200, 255, 0.7)';
                    ctx.fillRect(this.x, this.y, 2, this.size*2);
                }
            }

            class SnowFlake {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = -10;
                    this.speed = Math.random() * 2 + 1;
                    this.size = Math.random() * 5 + 4;
                    this.angle = Math.random() * Math.PI * 2;
                }
                update() {
                    this.y += this.speed;
                    this.x += Math.sin(this.angle * 0.5) * 1.5 + gameState.weather.windForce;
                    this.angle += 0.02;
                    if(this.y > canvas.height) this.reset();
                }
                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = -10;
                }
                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fill();
                }
            }


        // Weather system functions
        function updateWeather() {
            //debugger;
                if(Date.now() > gameState.weather.nextChange) {
                    const weatherTypes = ['sunny', 'rain', 'snow', 'windy'];
                    gameState.weather.current = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
                    gameState.weather.nextChange = Date.now() + 2000 + Math.random() * 2000;
                    gameState.weather.windForce = gameState.weather.current === 'windy' ? (Math.random() * 2 - 1) : 0;
                    
                    // Clear existing weather particles when changing
                    gameState.weather.particles = [];
                    
                    // Initialize new particles
                    if(gameState.weather.current === 'rain') {
                        for(let i = 0; i < 100; i++) gameState.weather.particles.push(new RainDrop());
                    }
                    if(gameState.weather.current === 'snow') {
                        for(let i = 0; i < 50; i++) gameState.weather.particles.push(new SnowFlake());
                    }
                }
        }


        // Game loop
        function gameLoop() {
            //debugger;
            if (!gameState.isPlaying || gameState.isPaused) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw background with reduced height (90% of canvas height)
                const bgHeight = canvas.height * 0.9;
                const bgY = (canvas.height - bgHeight) / 2;
                ctx.drawImage(images.background, 0, bgY, canvas.width, bgHeight);

            // Draw background image
            ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);

            // Update special animation state
            if (gameState.specialAnimation.active) {
                gameState.specialAnimation.framesRemaining--;
                if (gameState.specialAnimation.framesRemaining <= 0) {
                    gameState.specialAnimation.active = false;
                }
            }

            // Draw parallax layers
             gameState.backgrounds.forEach((layer, index) => {
                const img = images[`layer${index + 1}`];
                ctx.drawImage(img, layer.x, 0, canvas.width, canvas.height);
                ctx.drawImage(img, layer.x + canvas.width, 0, canvas.width, canvas.height);
            });

            updateParallax();



            new Bird().update();
            updateWeather();   // This line is added by myself
            gameState.weather.particles.forEach(p => {
                p.update();
                p.draw();
            });

            gameState.pipes.forEach(pipe => pipe.update());
            gameState.particles.forEach((particle, index) => {
                particle.update();
                if(particle.alpha <= 0) gameState.particles.splice(index, 1);
            });
            checkCollisions();
            spawnPipe();
            updateScore();
            gameState.pipes = gameState.pipes.filter(pipe => pipe.x > -gameState.pipeWidth);
            gameState.pipes.forEach(pipe => pipe.draw());
            new Bird().draw();
            gameState.particles.forEach(particle => particle.draw());

  
            requestAnimationFrame(gameLoop);
        }

        // Controls
        document.addEventListener('keydown', (e) => { 
            if (e.code === 'Space') {
                if (gameState.isPlaying) {
                    new Bird().flap();
                } else if (gameOverScreen.style.display === 'block') {
                    hideLeaderboard();
                    startGame();
                } else if (startScreen.style.display !== 'none') {
                    hideLeaderboard();
                    startGame();
                }
            }
            if (e.code === 'Escape') {
                gameState.isPaused = !gameState.isPaused;
                pauseMenu.style.display = gameState.isPaused ? 'block' : 'none';
                hideLeaderboard();
            }
        });
        canvas.addEventListener('click', () => {
            if (gameState.isPlaying) {
                new Bird().flap();
            } else if (gameOverScreen.style.display === 'block') {
                hideLeaderboard();
                startGame();
            }
        });
        document.addEventListener('click', () => { 
            if (audioContext.state === 'suspended') audioContext.resume();
        }, { once: true });
    </script>

    <!-- Add copyright notice in console -->
    <script>
        console.log('%c⚠️ WARNING: This game is protected by copyright! ⚠️\n%cUnauthorized copying/distribution is prohibited.',
                    'color: red; font-size: 18px;',
                    'color: orange; font-size: 14px;');
    </script>


      <!-- Particle Effects for Visual Flair (Add sparks when collecting points or hitting pipes) -->
    <script>
        // ... (keep existing game state and asset declarations unchanged) ... 

        // Enhanced Particle class with configurable properties
        // class Particle {
        //     constructor(x, y, color = '#f1c40f', size = Math.random() * 12 + 4, speedMultiplier = 1, decayRate = 0.02) {
        //         this.x = x;
        //         this.y = y;
        //         this.size = size;
        //         this.speedX = (Math.random() * 10 - 5) * speedMultiplier;
        //         this.speedY = (Math.random() * 10 - 5) * speedMultiplier;
        //         this.alpha = 1;
        //         this.color = color;
        //         this.decayRate = decayRate;
        //     }
        //     update() { 
        //         this.x += this.speedX; 
        //         this.y += this.speedY; 
        //         this.alpha -= this.decayRate; 
        //     }
        //     draw() {
        //         ctx.save(); 
        //         ctx.globalAlpha = this.alpha; 
        //         ctx.fillStyle = this.color;
        //         ctx.beginPath(); 
        //         ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); 
        //         ctx.fill(); 
        //         ctx.restore();
        //     }
        // }

        // Modified score handling with golden sparks
        function updateScore() {
            gameState.pipes.forEach(pipe => {
                if (!pipe.scored && pipe.x + gameState.pipeWidth < gameState.bird.x) {
                    pipe.scored = true;
                    gameState.score++;
                    scoreDisplay.textContent = `Score: ${gameState.score}`;
                    playPoint();


                    // Trigger special animation every 10 points
                    if (gameState.score % 10 === 0 && gameState.score > 0) {
                        gameState.specialAnimation.active = true;
                        gameState.specialAnimation.framesRemaining = 60; // 1 second
                        
                        // Add love emoji particles
                        const emojis = ['❤️', '💖', '😍', '💋'];
                        for (let i = 0; i < 25; i++) {
                            gameState.particles.push(new EmojiParticle(
                                gameState.bird.x,
                                gameState.bird.y,
                                emojis[Math.floor(Math.random() * emojis.length)],
                                '#FF69B4'
                            ));
                        }
                    }
                    
                    // Add golden score particles
                    for (let i = 0; i < 10; i++) {
                        gameState.particles.push(new Particle(
                            gameState.bird.x,
                            gameState.bird.y,
                            '#FFD700', // Gold color
                            Math.random() * 4 + 2, // Size between 2-6
                            2, // Speed multiplier
                            0.05 // Faster decay
                        ));
                    }
                }
            });
        }

        // Enhanced collision detection with impact particles
        function checkCollisions() {
            const hitboxScale = -0.5;
            const halfSize = gameState.bird.size/2 * hitboxScale;
            
            const birdLeft = gameState.bird.x - halfSize;
            const birdRight = gameState.bird.x + halfSize;
            const birdTop = gameState.bird.y - halfSize;
            const birdBottom = gameState.bird.y + halfSize;

            for (const pipe of gameState.pipes) {
                const pipeRight = pipe.x + gameState.pipeWidth;
                const pipeLeft = pipe.x;
                const pipeTopBottom = pipe.topHeight;
                const pipeBottomTop = pipe.bottomY;

                const horizontalCollision = birdRight > pipeLeft && birdLeft < pipeRight;
                const verticalCollision = 
                    (birdTop < pipeTopBottom && birdBottom > 0) ||
                    (birdBottom > pipeBottomTop && birdTop < canvas.height);

                if (horizontalCollision && verticalCollision) {
                    // Add red impact particles
                    for (let i = 0; i < 20; i++) {
                        gameState.particles.push(new Particle(
                            gameState.bird.x,
                            gameState.bird.y,
                            '#FF4500', // Orange-red color
                            Math.random() * 6 + 3, // Size between 3-9
                            1.5, // Speed multiplier
                            0.05 // Faster decay
                        ));
                    }
                    gameOver();
                    return;
                }
            }
        }

        // ... (keep remaining existing JavaScript code unchanged) ...
    </script>

    <script>
    

        // Weather particle classes
        class RainDrop123 {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = -10;
                this.speed = Math.random() * 8 + 8;
                this.size = Math.random() * 4 + 2;
            }
            update() {
                this.y += this.speed + gameState.weather.windForce/2;
                this.x += gameState.weather.windForce;
                if(this.y > canvas.height) this.reset();
            }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = -10;
            }
            draw() {
                ctx.fillStyle = 'rgba(150, 200, 255, 0.7)';
                ctx.fillRect(this.x, this.y, 2, this.size*2);
            }
        }

        class SnowFlake123 {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = -10;
                this.speed = Math.random() * 2 + 1;
                this.size = Math.random() * 3 + 2;
                this.angle = Math.random() * Math.PI * 2;
            }
            update() {
                this.y += this.speed;
                this.x += Math.sin(this.angle * 0.5) * 1.5 + gameState.weather.windForce;
                this.angle += 0.02;
                if(this.y > canvas.height) this.reset();
            }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = -10;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fill();
            }
        }

        // Weather system functions
        function updateWeather123() {
            if(Date.now() > gameState.weather.nextChange) {
                const weatherTypes = ['sunny', 'rain', 'snow', 'windy'];
                gameState.weather.current = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
                gameState.weather.nextChange = Date.now() + 500 + Math.random() * 500;
                gameState.weather.windForce = gameState.weather.current === 'windy' ? (Math.random() * 2 - 1) : 0;
                
                // Clear existing weather particles when changing
                gameState.weather.particles = [];
                
                // Initialize new particles
                if(gameState.weather.current === 'rain') {
                    for(let i = 0; i < 100; i++) gameState.weather.particles.push(new RainDrop());
                }
                if(gameState.weather.current === 'snow') {
                    for(let i = 0; i < 50; i++) gameState.weather.particles.push(new SnowFlake());
                }
            }
        }

        // Modified Bird class with wind effects
        class Bird {
            
            update() {
                if (!gameState.isPlaying || gameState.isPaused || !gameState.birdCanFall) return;
                
                // Apply wind force
                gameState.bird.x += gameState.weather.windForce;
                gameState.bird.velocity += gameState.bird.gravity + (gameState.weather.windForce * 0.1);
                
                // Keep bird in bounds horizontally
                gameState.bird.x = Math.max(gameState.bird.size/2, 
                    Math.min(canvas.width - gameState.bird.size/2, gameState.bird.x));
                
                // ... (rest of existing update code) ...
            }
            // ... (keep rest of Bird class unchanged) ...
        }

        // Modified game loop to include weather
        function gameLoop() {
            //debugger;
            if (!gameState.isPlaying || gameState.isPaused) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height);
            
            // Update and draw weather
            updateWeather();
            gameState.weather.particles.forEach(p => {
                p.update();
                p.draw();
            });

            // ... (rest of existing game loop code) ...
            
            requestAnimationFrame(gameLoop);
        }

        // ... (keep remaining existing JavaScript code unchanged) ...

        // Initialize weather system
        gameState.weather.nextChange = Date.now() + 1000;
    </script>

    <script>
        // ... (all previous JavaScript code remains unchanged until updateScore function) ...

        function updateScore() {
            gameState.pipes.forEach(pipe => {
                if (!pipe.scored && pipe.x + gameState.pipeWidth < gameState.bird.x) {
                    pipe.scored = true;
                    gameState.score++;
                    scoreDisplay.textContent = `Score: ${gameState.score}`;
                    playPoint();
                    
                    // Trigger special animation every 10 points
                    if (gameState.score % 5 === 0 && gameState.score > 0) {
                        gameState.specialAnimation.active = true;
                        gameState.specialAnimation.framesRemaining = 60; // 1 second
                        
                        // Add love emoji particles
                        const emojis = ['😍'];
                        for (let i = 0; i < 10; i++) {
                            gameState.particles.push(new EmojiParticle(
                                gameState.bird.x,
                                gameState.bird.y,
                                emojis[Math.floor(Math.random() * emojis.length)],
                                '#FF69B4'
                            ));
                        }
                    }


                    if ((gameState.score % 5 != 0) && gameState.score > 0)
                    {
                        for (let i = 0; i < 10; i++) {
                            gameState.particles.push(new Particle(
                                gameState.bird.x,
                                gameState.bird.y,
                                '#FFD700',
                                Math.random() * 4 + 2,
                                2,
                                0.05
                            ));
                       }

                    }

                    // Add golden score particles
                    // for (let i = 0; i < 10; i++) {
                    //     gameState.particles.push(new Particle(
                    //         gameState.bird.x,
                    //         gameState.bird.y,
                    //         '#FFD700',
                    //         Math.random() * 4 + 2,
                    //         2,
                    //         0.05
                    //     ));
                    // }
                }
            });
        }  // Added missing closing brace

        // ... (remaining existing JavaScript code unchanged) ...

        // Initialize weather system
        gameState.weather.nextChange = Date.now() + 1000;

        // Ensure all functions are properly defined in global scope
        window.startGame = startGame;
        window.resumeGame = resumeGame;
        window.restartGame = restartGame;
    </script>
    



</body>
</html>


<!-- Remember to:

Replace GA_MEASUREMENT_ID with your Google Analytics ID

Replace AD_CLIENT_ID with your AdSense publisher ID

Replace LEFT_AD_SLOT_ID and RIGHT_AD_SLOT_ID with your actual ad slot IDs

Ensure you comply with Google's policies regarding ads in games

Verify ad placements don't interfere with game controls

Adjust ad container widths and positions as needed for your layout -->